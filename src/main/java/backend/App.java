/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package backend;

import java.io.*;
import java.util.Optional;
import java.util.ArrayList;

import net.jpountz.lz4.LZ4BlockInputStream;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import tools.fasttrack_frontend.FTSerializedState;
import tools.fasttrack_frontend.FTSerializedStateSerializer;

public class App {
    
    public String getGreeting() {
        return "app should have a greeting";
    }

    public static void main(String[] args) {
        CommandLineParser parser = new DefaultParser();
        Options options = new Options();
        Option time = new Option("t", false, "measure execution time");
        Option silent = new Option("q", false, "do not carry out race detection");
        Option statistics = new Option("c", false, "show statistics of the log file");
        Option parallel = new Option("p", true, "enable parallel data race detection");
        Option sequential = new Option("s", false, "enable sequential data race detection");
        Option debug = new Option("d", false, "debug mode");

        options.addOption(time);
        options.addOption(silent);
        options.addOption(statistics);
        options.addOption(parallel);
        options.addOption(sequential);
        options.addOption(debug);

        CommandLine line = null;
        HelpFormatter help = new HelpFormatter();
        try {
            line = parser.parse(options, args);
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            help.printHelp("java App", options, true);
            System.exit(1);
        }

        long start = 0l;
        if (line.hasOption(time.getOpt())) {
            start = System.currentTimeMillis();
        }
        Kryo kryo = new Kryo();
        kryo.setReferences(false);
        kryo.setRegistrationRequired(true);
        kryo.register(FTSerializedState.class, new FTSerializedStateSerializer());
        long accessNum = 0L;
        if (line.getArgs().length == 0) {
            System.out.println("Please input log file");
            help.printHelp("java App", options, true);
            System.exit(1);
        }
        String logFolderName = line.getArgs()[0];
        File logFolder = new File(logFolderName);
        String benchmarkName = logFolderName.substring(logFolderName.lastIndexOf(File.separator) + 1);
        if (!logFolder.isDirectory()) {
            System.out.println(logFolder.getAbsolutePath() + " needs to be a vaild path to the folder containing log files");
            System.exit(1);
        } else if (!logFolder.canRead()) {
            System.out.println(logFolder.getAbsolutePath() + " needs to have read permission");
            System.exit(1);
        }

        FilenameFilter logFileFilter = new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.trim().endsWith(".log") ? true : false;
            }
        };

        ArrayList<Input> logFileInputs = new ArrayList<>();
        try {
            for (File logFile : logFolder.listFiles(logFileFilter)) {
                //Input input = new Input(new GZIPInputStream(new FileInputStream(logFile)));
                Input input = new Input(new LZ4BlockInputStream(new FileInputStream(logFile)));
                logFileInputs.add(input);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } /*catch (IOException e) {
            e.printStackTrace();
        }*/

        FrameInput input = new FrameInput(kryo, logFileInputs, 512);

        if (line.hasOption(statistics.getOpt())) {
            // statistics mode
            System.out.println("Statistics mode, calculate the distribution of memory accesses");
            Statistics ss = new Statistics(benchmarkName);
            Optional<FTSerializedState[]> frame = input.getNextFrame();
            while (frame.isPresent()) {
                ss.addFrame(frame.get());
                accessNum += frame.get().length;
                frame = input.getNextFrame();
            }
            ss.generateFigure();
        } else if (line.hasOption(silent.getOpt())) {
            // silent mode
            System.out.println("Silent mode, does not carry out data race detection");
            Optional<FTSerializedState[]> frame = input.getNextFrame();
            while (frame.isPresent()) {
                accessNum += frame.get().length;
                frame = input.getNextFrame();
            }
        } else if (line.hasOption(debug.getOpt())) {
            // debug mode, checking whether input file matches expectations
            System.out.println("Debug mode");
            Debug dbg = new Debug(benchmarkName);
            Optional<FTSerializedState[]> frame = input.getNextFrame();
            while (frame.isPresent()) {
                dbg.addFrame(frame.get());
                accessNum += frame.get().length;
                frame = input.getNextFrame();
            }
            dbg.findSingleAccessLocation();
        } else if (line.hasOption(parallel.getOpt())) {
            // parallel data race detection mode
            int parallelism = Integer.parseInt(line.getOptionValue(parallel.getOpt()));
            System.out.println("Parallel mode, detect data races in parallel with " + parallelism + " threads");
            //FixedParallelBlockingQueueFrameAnalyzer analyzer = new FixedParallelBlockingQueueFrameAnalyzer(parallelism);
            FixedParallelSPSCFrameAnalyzer analyzer = new FixedParallelSPSCFrameAnalyzer(parallelism);
            Optional<FTSerializedState[]> frame = input.getNextFrame();
            while (frame.isPresent()) {
                analyzer.addFrame(frame.get());
                accessNum += frame.get().length;
                frame = input.getNextFrame();
            }
            analyzer.noMoreInput();
            analyzer.close();
        } else if (line.hasOption(sequential.getOpt())){
            // sequential data race detection mode
            System.out.println("Sequential mode, detect data races sequentially");
            SequentialFrameAnalyzer analyzer = new SequentialFrameAnalyzer(true);
            Optional<FTSerializedState[]> frame = input.getNextFrame();
            while (frame.isPresent()) {
                analyzer.addFrame(frame.get());
                accessNum += frame.get().length;
                frame = input.getNextFrame();
            }
            analyzer.close();
        }

        long elapsedTime = 0l;
        if (line.hasOption(time.getOpt())) {
            elapsedTime = System.currentTimeMillis() - start;
            System.out.println("Elapsed Time: " + elapsedTime + " ms");
        }
        System.out.println("Number of memory accesses: " + accessNum);
    }
}
